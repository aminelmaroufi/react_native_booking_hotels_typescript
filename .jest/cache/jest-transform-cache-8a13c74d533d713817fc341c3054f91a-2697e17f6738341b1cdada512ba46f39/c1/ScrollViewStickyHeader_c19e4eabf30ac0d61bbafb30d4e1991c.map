{"version":3,"names":["_setAndForwardRef","_interopRequireDefault","require","_Platform","_StyleSheet","_Animated","React","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","AnimatedView","Animated","View","ScrollViewStickyHeaderWithForwardedRef","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","_nextHeaderLayoutY","nextHeaderLayoutY","_React$useState","useState","_React$useState2","_slicedToArray2","measured","setMeasured","_React$useState3","_React$useState4","layoutY","setLayoutY","_React$useState5","_React$useState6","layoutHeight","setLayoutHeight","_React$useState7","_React$useState8","translateY","setTranslateY","_React$useState9","_React$useState10","setNextHeaderLayoutY","_React$useState11","_React$useState12","isFabric","setIsFabric","componentRef","useRef","_setNativeRef","setAndForwardRef","getForwardedRef","setLocalRef","ref","current","_ref$_internalInstanc","_ref$_internalInstanc2","setNextHeaderY","value","stateNode","canonical","offset","useMemo","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","_React$useState13","initialTranslateY","add","_React$useState14","animatedTranslateY","setAnimatedTranslateY","_haveReceivedInitialZeroTranslateY","_timer","useEffect","animatedValueListener","useCallback","_ref","_debounceTimeout","Platform","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","passthroughAnimatedPropExplicitValues","style","transform","createElement","collapsable","nativeID","styles","header","cloneElement","fill","undefined","StyleSheet","create","zIndex","position","flex","_default","exports"],"sources":["ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\nimport setAndForwardRef from 'react-native/Libraries/Utilities/setAndForwardRef';\nimport Platform from '../../Utilities/Platform';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Animated from '../../Animated/Animated';\nimport * as React from 'react';\nimport {useEffect, useMemo, useRef, useCallback} from 'react';\n\nconst AnimatedView = Animated.View;\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<$FlowFixMe>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: Animated.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\n  Props,\n  $ReadOnly<{\n    setNextHeaderY: number => void,\n    ...$Exact<React.ElementRef<typeof AnimatedView>>,\n  }>,\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY,\n  } = props;\n\n  const [measured, setMeasured] = React.useState<boolean>(false);\n  const [layoutY, setLayoutY] = React.useState<number>(0);\n  const [layoutHeight, setLayoutHeight] = React.useState<number>(0);\n  const [translateY, setTranslateY] = React.useState<?number>(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] = React.useState<?number>(\n    _nextHeaderLayoutY,\n  );\n  const [isFabric, setIsFabric] = React.useState<boolean>(false);\n\n  const componentRef = React.useRef<?React.ElementRef<typeof AnimatedView>>();\n  const _setNativeRef = setAndForwardRef({\n    getForwardedRef: () => forwardedRef,\n    setLocalRef: ref => {\n      componentRef.current = ref;\n      if (ref) {\n        ref.setNextHeaderY = value => {\n          setNextHeaderLayoutY(value);\n        };\n        setIsFabric(\n          !!(\n            // An internal transform mangles variables with leading \"_\" as private.\n            // eslint-disable-next-line dot-notation\n            ref['_internalInstanceHandle']?.stateNode?.canonical\n          ),\n        );\n      }\n    },\n  });\n\n  const offset = useMemo(\n    () =>\n      hiddenOnScroll === true\n        ? Animated.diffClamp(\n            scrollAnimatedValue\n              .interpolate({\n                extrapolateLeft: 'clamp',\n                inputRange: [layoutY, layoutY + 1],\n                outputRange: ([0, 1]: Array<number>),\n              })\n              .interpolate({\n                inputRange: [0, 1],\n                outputRange: ([0, -1]: Array<number>),\n              }),\n            -layoutHeight,\n            0,\n          )\n        : null,\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\n  );\n\n  const [\n    animatedTranslateY,\n    setAnimatedTranslateY,\n  ] = React.useState<Animated.Node>(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n    const initialTranslateY: Animated.Interpolation = scrollAnimatedValue.interpolate(\n      {\n        inputRange,\n        outputRange,\n      },\n    );\n\n    if (offset != null) {\n      return Animated.add(initialTranslateY, offset);\n    }\n    return initialTranslateY;\n  });\n\n  const _haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\n  const _timer = useRef<?TimeoutID>(null);\n\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n\n  // This is called whenever the (Interpolated) Animated Value\n  // updates, which is several times per frame during scrolling.\n  // To ensure that the Fabric ShadowTree has the most recent\n  // translate style of this node, we debounce the value and then\n  // pass it through to the underlying node during render.\n  // This is:\n  // 1. Only an issue in Fabric.\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\n  //    can touch and move your finger slightly and still trigger\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\n  //    both Fabric and non-Fabric. On Android when you move\n  //    your finger, the hit-detection moves from the Android\n  //    platform to JS, so we need the ShadowTree to have knowledge\n  //    of the current position.\n  const animatedValueListener = useCallback(\n    ({value}) => {\n      const _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n      // When the AnimatedInterpolation is recreated, it always initializes\n      // to a value of zero and emits a value change of 0 to its listeners.\n      if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n        _haveReceivedInitialZeroTranslateY.current = true;\n        return;\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n      _timer.current = setTimeout(() => {\n        if (value !== translateY) {\n          setTranslateY(value);\n        }\n      }, _debounceTimeout);\n    },\n    [translateY],\n  );\n\n  useEffect(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n\n    // add the event listener\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(\n        animatedValueListener,\n      );\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n\n    // clean up the event listener and timer\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n\n  const _onLayout = (event: LayoutEvent) => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n\n    props.onLayout(event);\n    const child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  const child = React.Children.only(props.children);\n\n  // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n  const passthroughAnimatedPropExplicitValues =\n    isFabric && translateY != null\n      ? {\n          style: {transform: [{translateY: translateY}]},\n        }\n      : null;\n\n  return (\n    /* $FlowFixMe[prop-missing] passthroughAnimatedPropExplicitValues isn't properly\n       included in the Animated.View flow type. */\n    <AnimatedView\n      collapsable={false}\n      nativeID={props.nativeID}\n      onLayout={_onLayout}\n      ref={_setNativeRef}\n      style={[\n        child.props.style,\n        styles.header,\n        {transform: [{translateY: animatedTranslateY}]},\n      ]}\n      passthroughAnimatedPropExplicitValues={\n        passthroughAnimatedPropExplicitValues\n      }>\n      {React.cloneElement(child, {\n        style: styles.fill, // We transfer the child style to the wrapper.\n        onLayout: undefined, // we call this manually through our this._onLayout\n      })}\n    </AnimatedView>\n  );\n});\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nexport default ScrollViewStickyHeaderWithForwardedRef;\n"],"mappings":"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"}